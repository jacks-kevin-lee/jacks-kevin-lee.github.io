<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZCGR</title>
  
  <subtitle>zcgr</subtitle>
  <link href="https://www.zcgr.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.zcgr.xyz/"/>
  <updated>2023-01-20T08:49:20.699Z</updated>
  <id>https://www.zcgr.xyz/</id>
  
  <author>
    <name>kevin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>贫穷的痕迹，上大学就能抹去吗？</title>
    <link href="https://www.zcgr.xyz/traces-of-poverty/"/>
    <id>https://www.zcgr.xyz/traces-of-poverty/</id>
    <published>2023-01-10T08:36:06.000Z</published>
    <updated>2023-01-20T08:49:20.699Z</updated>
    
    <content type="html"><![CDATA[<p>作者：艾苓，黑龙江绥化学院教授。从教 17 年，接触学生超过 3000 人。2017 年通过社交平台发布《贫困生调查说明》，收到学生广泛响应。她详细追踪了 56 个孩子的人生轨迹，以当事人口述形式，记录下他们为了改变命运，做出的惊心动魄的努力。部分内容曾在《读库》发表，引发广泛讨论。</p><span id="more"></span><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/nYvjjmtGz3MtkVSqiaFpobJLhrU7wT3Q8icz7IumMpzvtZibicTMjhE1UuXcqE9bvnIupkFSBNWNObWWJrvjfbYpLA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>我的寒门学子</strong></p><p>“</p><p>上大学时，我和一位家境很好的同学逛超市。我觉得对方一定会买很多东西，我怕被看不起，就也买了一百多块钱的零食。结账时才发现，对方只花了五十多元，还有三十元买的是洗发水和沐浴露。同学问我为什么买那么多零食？我不知道该怎么回答，心里在滴血。</p><p>”</p><p>这是一个学生讲给我的故事。</p><p>我叫艾苓，在黑龙江绥化学院任教，一个二本院校。我在这里教书 17 年，接触过的孩子超过 3000 个，至少有三分之一的孩子来自贫困家庭。</p><p>这个学生的话让我意识到，虽然“寒门再难出贵子”“阶层固化”等类似的话题多次引爆热搜，但我们并不真正了解这些孩子，很多问题也一直没有得到解答：为什么有人说穷孩子和富孩子的脑电波都是不一样的？贫困如何留下了敏感自卑的心理烙印，限制了他们未来的发展？寒门为何再难出贵子？</p><p>这些答案只能走近穷孩子，在他们成长的故事里寻找。</p><p>2017 年初，我在社交平台上发布《贫困生调查说明》，邀请学生讲述自己的命运轨迹。<strong>这像一场冒险的社会实验，有可能会冒犯到他们。重新揭开伤疤，对他们来说很不容易。</strong></p><p>但出乎意料的是，学生们的响应特别热烈，即使多年前已经毕业的学生也参与进来，参与的学生前后多达 200 多人。他们说之前从来没有机会发出自己的声音。</p><p>我选择其中的 56 个孩子，听他们讲述自己幼年的生活，求学的不易，找工作的奔波直到结婚生子等人生关键阶段的故事，最终汇集成一本书《我教过的苦孩子》。</p><p>调查过程中，一个受访的男孩子说，<strong>贫困不只是一种物质状态，更是一种心理顽疾，即使成年后也很难摆脱，近乎一种贫困基因。</strong></p><p>这点也得到了很多读者的证实，一个女生说：虽然现在已经买了车，但我上班基本开电动车，很少开车，老公对于我的行为很不理解，其实我是心疼油钱，有时候小电驴没电我也会推回家。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/KIjYvJAEmk9t3bD38ia5TjibuWLic0q3icJ2icycUeljpJtI4ltDmykKDy5kNa0GqYng0w2FrddJ4NB2dlV4iayuHkow/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>▲ 图片来自《村小的孩子》</p><p>在此之前，我们很少从这个角度来看待贫穷的影响。随着调查的深入，我越来越确定一个观点：<strong>真正难以摆脱的，不是一时的经济困境，而是贫困滋生的心理习惯。它会导致贫困的再生产。这是寒门再难出贵子的一个核心原因。</strong></p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/nYvjjmtGz3MtkVSqiaFpobJLhrU7wT3Q8BqanHicsTpKWibgFEMTDZiaA9nyVOfXOnIQ0CbYaM5HxZviaPib8zAuXjjg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>贫穷的心理痕迹</strong></p><p>我采访的学生多是下岗职工、农民和进城务工人员的子女，家里多子女、单亲或者有病人。来绥化上大学，是很多人第一次坐火车或者第一次出远门。</p><p>他们自卑，敏感，朋友不多，坐在教室角落，很少主动跟老师互动，内心时常纠结。让他们纠结的可能是囊中羞涩，可能是自己的方言，可能是别人的某句话，可能是自己无法克服的紧张。</p><p>一个女孩子提到了一件至今耿耿于怀的事情：</p><p>“</p><p>小时候，我听到最多的话是“你们家穷”。穷，成了别人指责我家任何一个人的借口。有次同桌的钱丢了，一口咬定是我偷的。就连我妈妈都骂我说，不管咱家多穷，你也不该偷人家的钱。可是，我真的没偷。<strong>但就因为穷，别人就觉得你会干坏事。</strong></p><p>更夸张的时候，直到小学毕业时，同桌依然怀疑是我偷了钱。小学毕业的留言册上，那个女生给我写了这么几句话：“毕业快乐，一生平安！如果你以后知道谁偷了我的钱，记得让她把钱还给我！”她还是怀疑我，还是不依不饶。</p><p>”</p><p>这让她从小就特别敏感，继而自卑。这种情绪长久压抑，会淤积成心结。她总是生病，医生说：“这孩子的身体没什么大病，她的病根在心里，思虑过重。”</p><p>还有个女孩的情况更严重。父母都外出打工，她自小跟着爷爷奶奶生活。她说：“我经常有那种寄人篱下的心理。对别人的眼神特别敏感，极度自卑，想讨好所有人。”</p><p>三四年级的时候，她患上了抑郁症。为了排遣难过的情绪，她看了很多电视剧和四大名著绘本：我喜欢模仿其中的人物，模仿他们的台词和思维，在生活中假装大人。</p><p>或许在假装大人的那一刻，她才没那么无助和孤独。但“有一天张皇四顾，我不知道那些说话做事的人哪个人才是真正的自己。”</p><p>相比被保护得很好的孩子，这些苦孩子从小就背负了更多的心理负担。用我们今天的话来说，就是<strong>精神内耗</strong>。<strong>这会让他们的认知出现偏差，习惯性地认为自己不行，否定自己，会失去原本就属于他的机会。</strong></p><p>不管工作、情感都是如此：“大学同学都觉得我很成功，可我经常自卑。比如有时候岗位竞争，我就认为自己不行。”“贫困让我特别自卑。女生向我示好，曾心旌摇荡，但我不敢谈恋爱，觉得自己谁都不配。”背负这么多的精神负担，他们又怎么能走得更远呢？</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/KIjYvJAEmk9t3bD38ia5TjibuWLic0q3icJ2IFlDwdoq3fpI4gl20JeicusHfT4g0icj6ytdSJxzib8I80qlvar4728qw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>▲ Photo by Vadim Bogulov on Unsplash</p><p><strong>除了自卑，影响更大的是安全感的匮乏，这让他们在做决策时偏向保守，不能充分挖掘自己的人生潜力。</strong></p><p>一个受访的女孩在初中时成绩优秀，本来可以去省重点高中上学。但校长找到她，劝她留校就读，说只要每学期期末成绩保持在年级前十，就免三年学费。她最终选择了留在这里。因为父亲去世，母亲一个人挣钱养家，她想给母亲减轻一点负担。</p><p>这些孩子都是被贫困耽误的人，虽然他们都聪明，有超出常人的勤奋，在小学、初中时候都是班上的尖子生，还有很多是村子里的第一个大学生。但没有安全感，会让他们放弃更好的高中，或者是考研、出国的机会。</p><p>这一点得到了很多人的共鸣，一位读者讲了自己的故事：</p><p>当初毕业母亲重病去世，父亲年纪也大了，我直接放弃保研，自己出来上班还助学贷款和上学时候欠的债。现在看着考研的同学在大学教书，工作强度比我这个高中老师相差悬殊，收入和社会地位也无法相比，总之一言难尽。</p><p>他后来想了想又说：如果再给我机会，可能我还是会早早出来上班还债吧。</p><p>这是特别悲哀的事情。</p><p>调查的过程中，我一直琢磨一个问题，为什么苦孩子创业的少？为什么他们不敢放弃眼前稳当的环境，去争取更有挑战性的职位？后来我找到答案：<strong>因为他们输不起，对他们来说试错成本太高了。</strong></p><p>我在《我教过的苦孩子》追踪了这些孩子从出生到求学，从工作到结婚等人生关键阶段。这种长时段的观察，让贫困对人生的限制体现得更加突出。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/nYvjjmtGz3MtkVSqiaFpobJLhrU7wT3Q8Ta7xd4tYxK19iclmrQxYvcVlpvO7oW2HkxYcjWibQibJMnfRUs1W7R97w/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>摸爬式努力</strong></p><p>既然如此，上学是否还能改变他们的命运？答案依然是肯定的。其他阶层的孩子有更多的资源和机会，可以通过很多种方式成功。但对出身贫困的孩子来说，上大学很可能是风险最低，也是现有条件下最公平的上升通道。</p><p>我经常想起一个受访的男孩子。他高考时考了县里文科第五名，一家人历经艰辛才凑足了 5000 块的学费。他说：</p><p>“</p><p>上大学前那个晚上，大哥让大嫂炒了四个菜，请来叔叔、姐姐和姐夫，一家人为我送行。端起第一盅白酒，大哥泪眼模糊，四下环顾说：“爷爷奶奶、爸爸妈妈，你们放心吧，咱家终于有大学生了！”</p><p>那天晚上，那些离开的亲人好像就在身边，特别是帮我上学的奶奶，他们都参加了这次团圆饭。我对所有的亲人说：“谢谢你们！放心吧，我一定不负众望！”</p><p>”</p><p>大学教育不仅提供一个文凭，更是一个进入更广阔社会的机会，这对出身农村和边远地区的孩子尤其重要。正如我一开始就指出的那样：来绥化上大学，是很多人第一次坐火车或者第一次出远门。</p><p><strong>当然，这些苦孩子即使上了大学，人生道路也远比其他阶层的孩子艰难。</strong></p><p>很多中产家庭，以及出身更好的孩子，有好的资源支撑，一路几乎是“直升机式成长”。但贫困生不一样，他们只能一点一滴地在泥泞中摸爬，要走很多的弯路，然后取得一点点进步。</p><p>就像那句流传甚广的话：我奋斗了 18 年，才和你坐在一起喝咖啡。我用“摸爬式努力”这一概念，来描述这些苦孩子的努力过程。</p><p>有对 95 后情侣的故事特别动人，很好地展现了“摸爬式努力”的含义。</p><p>他们两个都来自贫困家庭，在北京漂泊，但他们为自己的目标做了特别务实的规划。</p><p>“</p><p>2019 年元旦那天，我俩把手写的小目标贴在墙上，其中一项是存款 15 万元。如果这个目标实现，我俩打算在呼和浩特买房。</p><p>”</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/KIjYvJAEmk9t3bD38ia5TjibuWLic0q3icJ2WPWHooERee35hA8eV1icbcVQ2yiaAMXKNoiaAzQxicKN6G45lRxoglLxxA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>▲ Photo by Timothy Buck on Unsplash</p><p>为了实现这个目标，他们做了细致的计划：</p><p>“</p><p>我们的日常支出主要是房租和伙食，搬到五环外，房租每月 2600 元就够了。平时公司管饭，周末我们自己做，每月支出计划是 1000 元。此外，还有交通费 500 元、水电费等 500 元、学习费 500 元、游玩费 800 元。</p><p>”</p><p>通过精打细算，他们实现了这个目标，然后继续下一个目标。</p><p>“</p><p>2020 年，我们贴在墙上的小目标是：在呼和浩特买我们的婚房和利用专长做副业。我们还在书架上贴了一句话：复盘完成，才算完成。每件事不是做完就完了，我们还得像下围棋一样复盘，总结得失。</p><p>”</p><p>很多孩子，都像这对情侣一样务实、灵活，<strong>他们知道自己的人生没法奢望一步到位，于是逐渐摸索出一种“小目标，多阶段”式的进阶方式，对目标进行精细化管理。</strong></p><p>虽然一开始起点可能很低，做销售、做运营，辗转多个城市、公司，但他们没有放弃“摸爬”，一点一点地追求一种细小的，但确定的幸福和成就。</p><p>上文那对 95 后情侣中的女孩子回忆说：</p><p>“</p><p>他们公司的下午茶有各种各样的水果和点心，小蛋糕每人一份，他一定带回来让我品尝。有一次，小蛋糕上有冰激凌，带回家的时候冰激凌已经化掉了。他给我讲冰激凌的造型，解释其中的创意，我好像真的看到小蛋糕原本的样子。</p><p>”</p><p>还有一对情侣终于买到了自己人生的第一套房：</p><p>“</p><p>2005 年 5 月装修完毕，我俩去新家，把屋里擦干净。他出去买东西，我在地板上打滚，阳光照在地板上，好像跟着我一起打滚，那种感觉太幸福了。</p><p>”</p><p>以往在讨论贫困生的时候，外界总有一种居高临下的怜悯，描述出来的画面也是苦涩的、灰暗的。在书中，我让这些孩子自己说话，全部采用自述的方式。<strong>我自己在听他们的故事时候，就有一种笃定的温暖的感觉，好几次忍不住落泪。</strong></p><p>那个患了抑郁症的女孩子上大学以后，用打工赚的钱去了趟长白山，“回到学校，一切还是原来的样子，但我看见谁都想笑，想想一路走来遇到的人和事，感觉自己很幸运，被世界温柔以待。”多年以后失去父亲，让她再次抑郁，在采访最后她说了这样一句话：</p><p>“</p><p>如果还有什么能够治愈创伤，那就是时间吧。</p><p>”</p><p>我追踪的这 56 个孩子，最终都通过漫长的努力实现了一定的阶层突围，至少比他们父辈走得更远。<strong>他们的人生就是走一步，再走一步，“终究能看到阳光照过来的那一刻”。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作者：艾苓，黑龙江绥化学院教授。从教 17 年，接触学生超过 3000 人。2017 年通过社交平台发布《贫困生调查说明》，收到学生广泛响应。她详细追踪了 56 个孩子的人生轨迹，以当事人口述形式，记录下他们为了改变命运，做出的惊心动魄的努力。部分内容曾在《读库》发表，引发广泛讨论。&lt;/p&gt;</summary>
    
    
    
    <category term="psychology" scheme="https://www.zcgr.xyz/all-categories/psychology/"/>
    
    
  </entry>
  
  <entry>
    <title>新的一年，从不给自己设限开始</title>
    <link href="https://www.zcgr.xyz/beijing-happy-valley-ph/"/>
    <id>https://www.zcgr.xyz/beijing-happy-valley-ph/</id>
    <published>2023-01-01T10:22:58.000Z</published>
    <updated>2023-01-20T08:06:17.381Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202301201605209.jpeg" alt="北京欢乐谷"></p><p>​    每年都想写些什么，但总找不到合适的动力。经历了2022年这一无常的一年，终于攒够了记录生活的动力。</p><span id="more"></span><p>​    2022全年总结：即使生活变成废墟，也要学会重建起自己的高楼来。去年好几次在知乎上看到有人在说，觉得自己很差劲，不知道该怎么继续。我也一样，有无数瞬间觉得自己差劲，发现天赋有限的瞬间，发现没人能说上几句话的瞬间，发现想抓住的没能抓住的瞬间。有时也会怀念过去，时间的滤镜让它们显得更熠熠生辉。但除此以外，我还会看看自己走过的路。有时我们翻山越岭，不一定能看到最初想看的风景。到了山头，不过是另一座山。但那一刻，你不会很慌张的，因为知道这座山是怎么上来的，下一座山，继续爬上去就是。最重要的不一定是山顶的风景，我认为是在旅途中明白更重要的东西 - 认识自己<br>​    新一年到来了，意味着在“二”的道路上没有几步可以走了。年龄增长的一大好处，就是知道该怎么与自己相处。即使孤独突如其来，命运常常作对，也知道该如何安顿情绪。逐渐萌生出了与之相匹配的坚韧。在过去的几年里，我看到即便是最努力的人，也得不到想要的结果；有些人竭尽全力，却又倒在梦想之前。我也逐渐发现，我们中很多人是没有退路的，退不回原点，因为原点压根不存在。三年来，我们都或多或少地度过了风雨飘摇的日夜。有时会觉得无力，对自身的无力。<br>然而在认识自我的过程中也重塑了自己。</p><p>​    在去年10月份的某一年我突然发觉，人是那么渺小，却又那么强大。即使浑身没有力气，即使内心已充满怀疑，也还是会在某一天，在废墟中重新站起，试着重建自己的楼，如同此时此刻的你一样。风雨还会再来，但你终于不再慌张，因为这一次你知道地基在哪，知道怎么砌砖。就是这样，不断被摧毁，又不断重建。步步碰壁，也步步前行。最后跌跌撞撞，终于找到了一种力量。那种力量不会轻易消失，因为它就来源于自身，来源于终于看到了自己的易碎，也看到了自己的坚不可摧。<br>​    我知道我还不愿意妥协，即便看到了生活的真相，也不想放弃热爱和坚持。那就尽力把这些都留住，承担所有代价。我们学会成长，就是认清自由背后的孤独，光鲜背后的艰辛，并心甘情愿地接受。最终我们能握住的，是能让我们坚定自我的习惯，能陪伴到最后的朋友——或许不会太多，但各个都很重要，还有，一个不再慌张的自己。<br>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202301201605209.jpeg&quot; alt=&quot;北京欢乐谷&quot;&gt;&lt;/p&gt;
&lt;p&gt;​    每年都想写些什么，但总找不到合适的动力。经历了2022年这一无常的一年，终于攒够了记录生活的动力。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Synchronized原理</title>
    <link href="https://www.zcgr.xyz/synchronized-principle/"/>
    <id>https://www.zcgr.xyz/synchronized-principle/</id>
    <published>2022-11-09T14:05:22.000Z</published>
    <updated>2022-11-12T02:19:11.083Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知 <code>synchronized</code> 锁在 <code>Java</code> 中经常使用它的源码是 <code>C++</code> 实现的，它的实现原理是怎样的呢？本文以 <code>OpenJDK 8</code> 为例探究以下内容。</p><span id="more"></span><!-- TOC --><hr><ul><li><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><h3 id="对象布局查看"><a href="#对象布局查看" class="headerlink" title="对象布局查看"></a>对象布局查看</h3><p>查看源代码之前，须熟悉java对象的布局，可以使用ClassLayout查看布局。</p><p>具体可以在 POM 文件中引入该依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">0.10</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用该语句可以获取对象的内存布局</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLayout.parseInstance(unsafeModel).toPrintable()</span><br></pre></td></tr></table></figure><h3 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h3><p>Java 内存对象由 3 部分组成</p><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211092237266.png" alt="img"></p><ul><li><p>Mark Word：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在 32 位系统占 4 字节，在 64 位系统中占 8 字节；</p></li><li><p>Class Pointer：用来指向对象对应的 Class 对象（其对应的元数据对象）的内存地址。在 32 位系统占 4 字节，在 64 位系统中占 8 字节；</p></li><li><p>Length：如果是数组对象，还有一个保存数组长度的空间，占 4 个字节；</p></li></ul><h3 id="对象数据"><a href="#对象数据" class="headerlink" title="对象数据"></a>对象数据</h3><p>对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte 和 boolean 是 1 个字节，short 和 char 是 2 个字节，int 和 float 是 4 个字节，long 和 double 是 8 个字节，reference 是 4 个字节（64 位系统中是 8 个字节）。</p><h3 id="对齐单元"><a href="#对齐单元" class="headerlink" title="对齐单元"></a>对齐单元</h3><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。对象头正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102223816.jpg" alt="img"></p><h3 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h3></li></ul><p>这里说明一下 32 位系统和 64 位系统中对象所占用内存空间的大小：</p><ul><li>在 32 位系统下，存放 Class Pointer 的空间大小是 4 字节，MarkWord 是 4 字节，对象头为 8 字节;</li><li>在 64 位系统下，存放 Class Pointer 的空间大小是 8 字节，MarkWord 是 8 字节，对象头为 16 字节;</li><li>64 位开启指针压缩的情况下，存放 Class Pointer 的空间大小是 4 字节，<code>MarkWord</code>是 8 字节，对象头为 12 字节;</li><li>如果是数组对象，对象头的大小为：数组对象头 8 字节+数组长度 4 字节+对齐 4 字节=16 字节。其中对象引用占 4 字节（未开启指针压缩的 64 位为 8 字节），数组<code>MarkWord</code>为 4 字节（64 位未开启指针压缩的为 8 字节）;</li><li>静态属性不算在对象大小内。</li></ul><p>​        可以看到，64 位 JVM 消耗的内存会比 32 位的要多大约 1.5 倍，这是因为对象指针在 64 位 JVM 下有更宽的寻址。对于那些将要从 32 位平台移植到 64 位的应用来说，平白无辜多了 1/2 的内存占用，这是开发者不愿意看到的。</p><p>​        从 JDK 1.6 update14 开始，64 位的 JVM 正式支持了 -XX:+UseCompressedOops 这个可以压缩指针，起到节约内存占用的新参数。</p><p>​        在 Java 程序启动时增加 JVM 参数：<code>-XX:+UseCompressedOops</code>来启用。JDK 1.8，默认该参数就是开启的。</p><ul><li><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h2></li></ul><p>首先先简单的写 2 个有 synchronized 的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSpin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印对象头&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">4</span>) &#123;</span><br><span class="line">                    System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testSpin1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印对象头&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 javap -v -p 反编译后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void testSpin();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=3, locals=4, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: getfield      #3                  // Field lock:Ljava/lang/Object;</span><br><span class="line">        4: dup</span><br><span class="line">        5: astore_1</span><br><span class="line">        6: monitorenter      //锁进入                 </span><br><span class="line">        7: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       10: new           #12                 // class java/lang/StringBuilder</span><br><span class="line">       13: dup</span><br><span class="line">       14: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       17: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       20: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       23: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       26: ldc           #17                 // String 打印对象头</span><br><span class="line">       28: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       31: invokevirtual #18                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">       34: invokevirtual #19                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       37: iconst_0</span><br><span class="line">       38: istore_2</span><br><span class="line">       39: iload_2</span><br><span class="line">       40: iconst_5</span><br><span class="line">       41: if_icmpge     71</span><br><span class="line">       44: iload_2</span><br><span class="line">       45: iconst_4</span><br><span class="line">       46: if_icmpne     65</span><br><span class="line">       49: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       52: aload_0</span><br><span class="line">       53: getfield      #3                  // Field lock:Ljava/lang/Object;</span><br><span class="line">       56: invokestatic  #20                 // Method org/openjdk/jol/info/ClassLayout.parseInstance:(Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">       59: invokevirtual #21                 // Method org/openjdk/jol/info/ClassLayout.toPrintable:()Ljava/lang/String;</span><br><span class="line">       62: invokevirtual #19                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       65: iinc          2, 1</span><br><span class="line">       68: goto          39</span><br><span class="line">       71: aload_1</span><br><span class="line">       72: monitorexit     //锁释放 </span><br><span class="line">       73: goto          81</span><br><span class="line">       76: astore_3</span><br><span class="line">       77: aload_1</span><br><span class="line">       78: monitorexit    //锁释放 </span><br><span class="line">       79: aload_3</span><br><span class="line">       80: athrow</span><br><span class="line">       81: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            7    73    76   any</span><br><span class="line">           76    79    76   anyåå</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void testSpin1();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_SYNCHRONIZED // 锁标志</span><br><span class="line">   Code:</span><br><span class="line">     stack=3, locals=3, args_size=1</span><br><span class="line">        0: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        3: new           #12                 // class java/lang/StringBuilder</span><br><span class="line">        6: dup</span><br><span class="line">        7: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       10: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       13: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       16: invokevirtual #16      </span><br></pre></td></tr></table></figure><p>上面反编译后的代码可以看出，同步代码块是 monitorenter 和 monitorexit 实现的，同步方法是通过 ACC_SYNCHRONIZED 标志实现的。</p><p>首先我们来看一下 JVM 规范中对于<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">monitorenter</a>和<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">monitorexit</a>的描述：</p><h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes <em>monitorenter</em> attempts to gain ownership of the monitor associated with <em>objectref</em>, as follows:</p><ul><li>If the entry count of the monitor associated with <em>objectref</em> is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</li><li>If the thread already owns the monitor associated with <em>objectref</em>, it reenters the monitor, incrementing its entry count.</li><li>If another thread already owns the monitor associated with <em>objectref</em>, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</li></ul><p>翻译过来：</p><p>每一个对象都会和一个监视器 monitor 关联。监视器被占用时会被锁住，其他线程无法来获取该 monitor。当 JVM 执行某个线程的某个方法内部的 monitorenter 时，它会尝试去获取当前对象对应的 monitor 的所有权。其过程如下：</p><ol><li><p>若 monior 的进入数为 0，线程可以进入 monitor，并将 monitor 的进入数置为 1。当前线程成为 monitor 的 owner（所有者）</p></li><li><p>若线程已拥有 monitor 的所有权，允许它重入 monitor，则进入 monitor 的进入数加 1</p></li><li><p>若其他线程已经占有 monitor 的所有权，那么当前尝试获取 monitor 的所有权的线程会被阻塞，直到 monitor 的进入数变为 0，才能重新尝试获取 monitor 的所有权。</p></li></ol><p>synchronized 的锁对象会关联一个 monitor,这个 monitor 不是我们主动创建的,是 JVM 的线程执行到这个同步代码块,发现锁对象没有 monitor 就会创建 monitor,monitor 内部有两个重要的成员变量 owner:拥有这把锁的线程,recursions 会记录线程拥有锁的次数,当一个线程拥有 monitor 后其他线程只能等待。</p><h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><p>The <em>objectref</em> must be of type <code>reference</code>.</p><p>The thread that executes <em>monitorexit</em> must be the owner of the monitor associated with the instance referenced by <em>objectref</em>.</p><p>The thread decrements the entry count of the monitor associated with <em>objectref</em>. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p><p>翻译过来：</p><ol><li><p>能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程。</p></li><li><p>执行 monitorexit 时会将 monitor 的进入数减 1。当 monitor 的进入数减为 0 时，当前线程退出 monitor，不再拥有 monitor 的所有权，此时其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权。</p></li></ol><p>monitorexit 插入在方法结束处和异常处，JVM 保证每个 monitorenter 必须有对应的 monitorexit。</p><h3 id="同步方法（ACC-SYNCHRONIZED）"><a href="#同步方法（ACC-SYNCHRONIZED）" class="headerlink" title="同步方法（ACC_SYNCHRONIZED）"></a>同步方法（ACC_SYNCHRONIZED）</h3><p>首先看看<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">JVM文档</a>对于 Synchronization 的介绍，可以总结为：同步方法在反汇编后，会增加 ACC_SYNCHRONIZED 修饰。会隐式调用 monitorenter 和 monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。</p><h3 id="monitor-锁"><a href="#monitor-锁" class="headerlink" title="monitor 锁"></a>monitor 锁</h3><p>可以看出无论是 synchronized 代码块还是 synchronized 方法，其线程安全的语义实现最终依赖一个叫 monitor 的东西，那么这个神秘的东西,是什么呢？</p><p>下面让我们来详细介绍一下。在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 c++来实现的，位于 HotSpot 虚拟机源码<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/69087d08d473/src/share/vm/runtime/objectMonitor.hpp">ObjectMonitor.hpp</a>文件中。ObjectMonitor 主要数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;<span class="comment">// 线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;<span class="comment">// 存储该monitor的对象</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>;<span class="comment">// 标识拥有该monitor的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;<span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;<span class="comment">// 多线程竞争锁时的单向列表</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;<span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>owner：初始时为 NULL。当有线程占有该 monitor 时，owner 标记为该线程的唯一标识。当线程释放 monitor 时，owner 又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线程安全的。</li><li>cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。cxq 是一个临界资源，JVM 通过 CAS 原子指令来修改 cxq 队列。修改前 cxq 的旧值填入了 node 的 next 字段，cxq 指向新值（新线程）。因此 cxq 是一个后进先出的 stack（栈）。</li><li>EntryList：cxq 队列中有资格成为候选资源的线程会被移动到该队列中。</li><li>WaitSet：因为调用 wait 方法而被阻塞的线程会被放在该队列中。</li></ol><p>每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor。</p><p>我们的 Java 代码里不会显示地去创造这么一个 monitor 对象，我们也无需创建，事实上可以这么理解：monitor 并不是随着对象创建而创建的。我们是通过 synchronized 修饰符告诉 JVM 需要为我们的某个对象创建关联的 monitor 对象。每个线程都存在两个 ObjectMonitor 对象列表，分别为 free 和 used 列表。同时 JVM 中也维护着 global locklist。当线程需要 ObjectMonitor 对象时，首先从线程自身的 free 表中申请，若存在则使用，若不存在则从 global list 中申请。</p><p>ObjectMonitor 的数据结构中包含：owner、WaitSet 和_EntryList，它们之间的关系转换可以用下图表示：</p><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211092247770.jpeg" alt="img"></p><ul><li><h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2></li></ul><p>高效并发是从 JDK 5 到 JDK 6 的一个重要改进，HotSpot 虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102227819.png" alt="img"></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是 JDK 6 中的重要引进，因为 HotSpot 作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程 ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID 即可。</p><h4 id="偏向锁与-hashcode"><a href="#偏向锁与-hashcode" class="headerlink" title="偏向锁与 hashcode"></a>偏向锁与 hashcode</h4><p>偏向锁的时候，对象头中保存的是线程 ID，那么 hashcode 保存在哪里呢，或者是先计算了 hashcode，还能实现偏向锁吗？</p><ul><li>当一个对象已经计算过 identity hash code，它就无法进入偏向锁状态；</li><li>当一个对象当前正处于偏向锁状态，并且需要计算其 identity hash code 的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li><li>重量锁的实现中，ObjectMonitor 类里有字段可以记录非加锁状态下的 mark word，其中可以存储 identity hash code 的值。或者简单说就是重量锁可以存下 identity hash code。</li></ul><blockquote><p>请一定要注意，这里讨论的 hash code 都只针对 identity hash code。用户自定义的 hashCode()方法所返回的值跟这里讨论的不是一回事。Identity hash code 是未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。</p></blockquote><h4 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h4><p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p><ol><li>虚拟机将会把对象头中的偏向模式为“1”，即偏向模式；</li><li>同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li></ol><p>具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 Java 虚拟机会通过 CAS 操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为：1 01；</p><p>在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为： 1 01，是否包含当前线程的地址，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回；</p><h4 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h4><ol><li>偏向锁的撤销动作必须等待<a href="https://www.zhihu.com/question/29268019">safepoint</a>（<a href="https://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html">安全点</a>）<a href="https://www.jianshu.com/p/c79c5e02ebe6">其他资料</a>；</li><li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态；</li><li>撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态。</li></ol><h4 id="epoch-是什么"><a href="#epoch-是什么" class="headerlink" title="epoch 是什么"></a>epoch 是什么</h4><p>如果某一类锁对象的总撤销数超过了一个阈值（对应 jvm 参数 <strong>-XX:BiasedLockingBulkRebiasThreshold，默认为 20</strong>），那么 Java 虚拟机会宣布这个类的偏向锁失效；进行<strong>批量重偏向；</strong>具体的做法便是在每个类中维护一个 epoch 值，你可以理解为第几代偏向锁。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中；</p><p>在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值；为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态；</p><p>如果总撤销数超过另一个阈值（对应 jvm 参数 <strong>-XX:BiasedLockingBulkRevokeThreshold，默认值为 40</strong>），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁(这里说的就是<strong>偏向批量撤销</strong>)。</p><h4 id="偏向锁的相关参数"><a href="#偏向锁的相关参数" class="headerlink" title="偏向锁的相关参数"></a>偏向锁的相关参数</h4><p>偏向锁在 Java 6 之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用<code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p><h4 id="偏向锁的使用场景"><a href="#偏向锁的使用场景" class="headerlink" title="偏向锁的使用场景"></a>偏向锁的使用场景</h4><ol><li><strong>偏向锁是为了在资源没有被多线程竞争的情况下尽量减少锁带来的性能开销。</strong></li><li>在锁对象的对象头中有一个<code>ThreadId</code>字段，当<strong>第一个线程访问锁</strong>时，如果<strong>该锁没有被其他线程访问过</strong>，即 <strong><code>ThreadId</code>字段为空</strong>，那么 JVM 让其持有偏向锁，并将<code>ThreadId</code>字段的值设置为该线程的<code>ID</code>。当下一次获取锁的时候，会判断<code>ThreadId</code>是否相等，如果一致就不会重复获取锁，从而提高了运行效率。</li><li>如果存在锁的竞争情况，偏向锁就会被撤销并升级为轻量级锁。</li></ol><h4 id="偏向锁的状态"><a href="#偏向锁的状态" class="headerlink" title="偏向锁的状态"></a>偏向锁的状态</h4><p>匿名偏向(Anonymously biased)在此状态下<code>thread pointer</code>为<code>NULL(0)</code>，意味着还没有线程偏向于这个锁对象。第一个试图获取该锁的线程将会面临这个情况，使用原子<code>CAS</code>指令可将该锁对象绑定于当前线程。这是允许偏向锁的类对象的初始状态。</p><p>可重偏向(Rebiasable)在此状态下，偏向锁的<code>epoch</code>字段是无效的（与锁对象对应的 class 的 mark_prototype 的 epoch 值不匹配）。下一个试图获取锁对象的线程将会面临这个情况，使用原子 CAS 指令可将该锁对象绑定于当前线程**。在批量重偏向的操作中，未被持有的锁对象都被至于这个状态，以便允许被快速重偏向。</p><p>已偏向(Biased)这种状态下，<code>thread pointer</code>非空，且<code>epoch</code>为有效值——意味着其他线程正在持有这个锁对象。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h4><p>轻量级锁是 JDK 6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p><h4 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h4><p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则 JVM 首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102247807.jpeg" alt="img"></p><ol start="2"><li>JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果成功表示竞争到锁，则将锁标志位变成 00，执行同步操作。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102248382.jpeg" alt="img"></p><ol start="3"><li>如果失败则，这种情况：<ol><li> 判断当前对象的 Mark Word 是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，再增加一个 lock record，如图所示，然后执行同步代码块。</li><li>否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成 10，后面等待的线程将会进入阻塞状态。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102248676.png" alt="img"></p><h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：</p><ol><li><p>取出在获取轻量级锁保存在 Displaced Mark Word 中的数据。</p></li><li><p>用 CAS 操作将取出的数据替换当前对象的 Mark Word 中，如果成功，则说明释放锁成功。</p></li><li><p>如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。</p></li></ol><h4 id="轻量级锁的使用场景"><a href="#轻量级锁的使用场景" class="headerlink" title="轻量级锁的使用场景"></a>轻量级锁的使用场景</h4><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p><h3 id="重量级锁自旋锁"><a href="#重量级锁自旋锁" class="headerlink" title="重量级锁自旋锁"></a>重量级锁自旋锁</h3><p>前面我们讨论 monitor 实现锁的时候，知道 monitor 会阻塞和唤醒线程，线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自旋) , 这项技术就是所谓的自旋锁。自旋锁在 JDK 1.4.2 中就已经引入，只不过默认是关闭的，可以使用<code>-XX:+UseSpinning</code> 参数来开启，在 JDK 6 中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p><p>自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户可以使用参数<code>-XX : PreBlockSpin</code> 来更改。</p><h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>在 JDK 6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如 100 次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器（<a href="https://xie.infoq.cn/link?target=http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">JIT</a>）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><p>锁消除的主要判定依据来源于<strong>逃逸分析（参考附录</strong>）的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><p>变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在 Java 程序中的普遍程度也许超过了大部分读者的想象。</p><p>下面这段非常简单的代码仅仅是输出 3 个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步,虚拟机发现它的动态作用域被限制在 concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃逸”到 concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockCoarsening</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        concatString(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String str1, String str2, String str3, String str4)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(str1).append(str2).append(str3).append(str4).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制代码</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知 &lt;code&gt;synchronized&lt;/code&gt; 锁在 &lt;code&gt;Java&lt;/code&gt; 中经常使用它的源码是 &lt;code&gt;C++&lt;/code&gt; 实现的，它的实现原理是怎样的呢？本文以 &lt;code&gt;OpenJDK 8&lt;/code&gt; 为例探究以下内容。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://www.zcgr.xyz/all-categories/technology/"/>
    
    
    <category term="synchronized" scheme="https://www.zcgr.xyz/all-tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Psychology-Test1</title>
    <link href="https://www.zcgr.xyz/psychology-test1/"/>
    <id>https://www.zcgr.xyz/psychology-test1/</id>
    <published>2022-11-06T15:51:35.000Z</published>
    <updated>2023-01-20T08:21:12.284Z</updated>
    
    <content type="html"><![CDATA[<p>psychology-test1</p><span id="more"></span><p>aljfd你的卡 萨达殴打后 哈斯都爱</p><h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><h3 id="三标题1"><a href="#三标题1" class="headerlink" title="三标题1"></a>三标题1</h3><h4 id="四标题"><a href="#四标题" class="headerlink" title="四标题"></a>四标题</h4><p>正文</p><h3 id="三标题2"><a href="#三标题2" class="headerlink" title="三标题2"></a>三标题2</h3><h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><h1 id="你好2"><a href="#你好2" class="headerlink" title="你好2"></a>你好2</h1><h1 id="你好3"><a href="#你好3" class="headerlink" title="你好3"></a>你好3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;psychology-test1&lt;/p&gt;</summary>
    
    
    
    <category term="psychology" scheme="https://www.zcgr.xyz/all-categories/psychology/"/>
    
    
  </entry>
  
  <entry>
    <title>Photography-Test1</title>
    <link href="https://www.zcgr.xyz/photography-test1/"/>
    <id>https://www.zcgr.xyz/photography-test1/</id>
    <published>2022-11-06T15:51:29.000Z</published>
    <updated>2022-11-07T04:34:19.219Z</updated>
    
    <content type="html"><![CDATA[<p>photography-test1</p><span id="more"></span><p>daio doiosadjuioasd</p><h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><h3 id="三标题1"><a href="#三标题1" class="headerlink" title="三标题1"></a>三标题1</h3><h4 id="四标题"><a href="#四标题" class="headerlink" title="四标题"></a>四标题</h4><p>正文</p><h3 id="三标题2"><a href="#三标题2" class="headerlink" title="三标题2"></a>三标题2</h3><h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><h1 id="你好2"><a href="#你好2" class="headerlink" title="你好2"></a>你好2</h1><h1 id="你好3"><a href="#你好3" class="headerlink" title="你好3"></a>你好3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;photography-test1&lt;/p&gt;</summary>
    
    
    
    <category term="photography" scheme="https://www.zcgr.xyz/all-categories/photography/"/>
    
    
  </entry>
  
  <entry>
    <title>Technology-Test1</title>
    <link href="https://www.zcgr.xyz/technology-test1/"/>
    <id>https://www.zcgr.xyz/technology-test1/</id>
    <published>2022-11-06T15:51:24.000Z</published>
    <updated>2023-01-20T08:21:22.846Z</updated>
    
    <content type="html"><![CDATA[<p>technology-test1</p><span id="more"></span><p>asasasafp激斗啊手动滑稽哦啊 </p><!-- toc --><hr><h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><h3 id="三标题1"><a href="#三标题1" class="headerlink" title="三标题1"></a>三标题1</h3><h4 id="四标题"><a href="#四标题" class="headerlink" title="四标题"></a>四标题</h4><p>正文</p><h3 id="三标题2"><a href="#三标题2" class="headerlink" title="三标题2"></a>三标题2</h3><h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><h1 id="你好2"><a href="#你好2" class="headerlink" title="你好2"></a>你好2</h1><h1 id="你好3"><a href="#你好3" class="headerlink" title="你好3"></a>你好3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;technology-test1&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://www.zcgr.xyz/all-categories/technology/"/>
    
    
  </entry>
  
  <entry>
    <title>Psychology-Test</title>
    <link href="https://www.zcgr.xyz/psychology-test/"/>
    <id>https://www.zcgr.xyz/psychology-test/</id>
    <published>2022-11-06T15:49:18.000Z</published>
    <updated>2023-01-20T08:21:05.428Z</updated>
    
    <content type="html"><![CDATA[<p>psychology test</p><span id="more"></span><p>宋丹丹克拉斯</p><h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><h3 id="三标题1"><a href="#三标题1" class="headerlink" title="三标题1"></a>三标题1</h3><h4 id="四标题"><a href="#四标题" class="headerlink" title="四标题"></a>四标题</h4><p>正文</p><h3 id="三标题2"><a href="#三标题2" class="headerlink" title="三标题2"></a>三标题2</h3><h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><h1 id="你好2"><a href="#你好2" class="headerlink" title="你好2"></a>你好2</h1><h1 id="你好3"><a href="#你好3" class="headerlink" title="你好3"></a>你好3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;psychology test&lt;/p&gt;</summary>
    
    
    
    <category term="psychology" scheme="https://www.zcgr.xyz/all-categories/psychology/"/>
    
    
  </entry>
  
  <entry>
    <title>Photography-Test</title>
    <link href="https://www.zcgr.xyz/photography-test/"/>
    <id>https://www.zcgr.xyz/photography-test/</id>
    <published>2022-11-06T15:49:03.000Z</published>
    <updated>2023-01-20T08:20:57.489Z</updated>
    
    <content type="html"><![CDATA[<p>photography test</p><span id="more"></span><p>this is a fjio haioh   hlaiu faU joi ioufio i oo9u </p><p>会 还否发noise哦是的if偶哦发货i哦发你偶会发哦是i欧皇发i哦啊方i哦票发</p><h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><h3 id="三标题1"><a href="#三标题1" class="headerlink" title="三标题1"></a>三标题1</h3><h4 id="四标题"><a href="#四标题" class="headerlink" title="四标题"></a>四标题</h4><p>正文</p><h3 id="三标题2"><a href="#三标题2" class="headerlink" title="三标题2"></a>三标题2</h3><h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><h1 id="你好2"><a href="#你好2" class="headerlink" title="你好2"></a>你好2</h1><h1 id="你好3"><a href="#你好3" class="headerlink" title="你好3"></a>你好3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;photography test&lt;/p&gt;</summary>
    
    
    
    <category term="photography" scheme="https://www.zcgr.xyz/all-categories/photography/"/>
    
    
  </entry>
  
  <entry>
    <title>Technology-Test</title>
    <link href="https://www.zcgr.xyz/technology-test/"/>
    <id>https://www.zcgr.xyz/technology-test/</id>
    <published>2022-11-06T15:48:46.000Z</published>
    <updated>2023-01-20T08:20:53.441Z</updated>
    
    <content type="html"><![CDATA[<p>technology test</p><span id="more"></span><p>ash几aDSIO啊手机哦i啊SJIOA</p><h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><h3 id="三标题1"><a href="#三标题1" class="headerlink" title="三标题1"></a>三标题1</h3><h4 id="四标题"><a href="#四标题" class="headerlink" title="四标题"></a>四标题</h4><p>正文</p><h3 id="三标题2"><a href="#三标题2" class="headerlink" title="三标题2"></a>三标题2</h3><h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><h1 id="你好2"><a href="#你好2" class="headerlink" title="你好2"></a>你好2</h1><h1 id="你好3"><a href="#你好3" class="headerlink" title="你好3"></a>你好3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;technology test&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://www.zcgr.xyz/all-categories/technology/"/>
    
    
    <category term="java" scheme="https://www.zcgr.xyz/all-tags/java/"/>
    
    <category term="php" scheme="https://www.zcgr.xyz/all-tags/php/"/>
    
  </entry>
  
</feed>
