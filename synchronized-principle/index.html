
<!DOCTYPE html>
<html lang="zh-cn,en,default">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="ZCGR">
    <title>Synchronized原理 - ZCGR</title>
    <meta name="author" content="kevin">
    
        <meta name="keywords" content="hexo,ZCGR,zcgr.xyz,">
    
    
        <link rel="icon" href="https://www.zcgr.xyz/assets/images/author.jpg">
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kevin","sameAs":["mailto"],"image":"author.jpg"},"articleBody":"众所周知 synchronized 锁在 Java 中经常使用它的源码是 C++ 实现的，它的实现原理是怎样的呢？本文以 OpenJDK 8 为例探究以下内容。\n\n\n\n\n\n\n\n\n内存布局对象布局查看查看源代码之前，须熟悉java对象的布局，可以使用ClassLayout查看布局。\n具体可以在 POM 文件中引入该依赖\n12345&lt;dependency&gt;       &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;       &lt;artifactId&gt;jol-core&lt;/artifactId&gt;       &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;\n\n使用该语句可以获取对象的内存布局\n1ClassLayout.parseInstance(unsafeModel).toPrintable()\n\n对象组成Java 内存对象由 3 部分组成\n\n\nMark Word：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在 32 位系统占 4 字节，在 64 位系统中占 8 字节；\n\nClass Pointer：用来指向对象对应的 Class 对象（其对应的元数据对象）的内存地址。在 32 位系统占 4 字节，在 64 位系统中占 8 字节；\n\nLength：如果是数组对象，还有一个保存数组长度的空间，占 4 个字节；\n\n\n对象数据对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte 和 boolean 是 1 个字节，short 和 char 是 2 个字节，int 和 float 是 4 个字节，long 和 double 是 8 个字节，reference 是 4 个字节（64 位系统中是 8 个字节）。\n对齐单元对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。对象头正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。\n对象头\n指针压缩\n\n这里说明一下 32 位系统和 64 位系统中对象所占用内存空间的大小：\n\n在 32 位系统下，存放 Class Pointer 的空间大小是 4 字节，MarkWord 是 4 字节，对象头为 8 字节;\n在 64 位系统下，存放 Class Pointer 的空间大小是 8 字节，MarkWord 是 8 字节，对象头为 16 字节;\n64 位开启指针压缩的情况下，存放 Class Pointer 的空间大小是 4 字节，MarkWord是 8 字节，对象头为 12 字节;\n如果是数组对象，对象头的大小为：数组对象头 8 字节+数组长度 4 字节+对齐 4 字节=16 字节。其中对象引用占 4 字节（未开启指针压缩的 64 位为 8 字节），数组MarkWord为 4 字节（64 位未开启指针压缩的为 8 字节）;\n静态属性不算在对象大小内。\n\n​        可以看到，64 位 JVM 消耗的内存会比 32 位的要多大约 1.5 倍，这是因为对象指针在 64 位 JVM 下有更宽的寻址。对于那些将要从 32 位平台移植到 64 位的应用来说，平白无辜多了 1/2 的内存占用，这是开发者不愿意看到的。\n​        从 JDK 1.6 update14 开始，64 位的 JVM 正式支持了 -XX:+UseCompressedOops 这个可以压缩指针，起到节约内存占用的新参数。\n​        在 Java 程序启动时增加 JVM 参数：-XX:+UseCompressedOops来启用。JDK 1.8，默认该参数就是开启的。\n\nsynchronized原理\n\n首先先简单的写 2 个有 synchronized 的代码\n12345678910111213141516171819202122232425public void testSpin() &#123;        synchronized (lock) &#123;            System.out.println(Thread.currentThread().getName() + &quot;打印对象头&quot;);            for (int i = 0; i &lt; 5; i++) &#123;                if (i==4) &#123;                    System.out.println(ClassLayout.parseInstance(lock).toPrintable());                &#125;            &#125;        &#125;    &#125;    public synchronized void testSpin1() &#123;        synchronized (lock) &#123;            System.out.println(Thread.currentThread().getName() + &quot;打印对象头&quot;);            for (int i = 0; i &lt; 5; i++) &#123;                System.out.println(ClassLayout.parseInstance(lock).toPrintable());                try &#123;                    lock.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;\n\n通过 javap -v -p 反编译后\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void testSpin();   descriptor: ()V   flags: ACC_PUBLIC   Code:     stack=3, locals=4, args_size=1        0: aload_0        1: getfield      #3                  // Field lock:Ljava/lang/Object;        4: dup        5: astore_1        6: monitorenter      //锁进入                         7: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;       10: new           #12                 // class java/lang/StringBuilder       13: dup       14: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V       17: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;       20: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;       23: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;       26: ldc           #17                 // String 打印对象头       28: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;       31: invokevirtual #18                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;       34: invokevirtual #19                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V       37: iconst_0       38: istore_2       39: iload_2       40: iconst_5       41: if_icmpge     71       44: iload_2       45: iconst_4       46: if_icmpne     65       49: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;       52: aload_0       53: getfield      #3                  // Field lock:Ljava/lang/Object;       56: invokestatic  #20                 // Method org/openjdk/jol/info/ClassLayout.parseInstance:(Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;       59: invokevirtual #21                 // Method org/openjdk/jol/info/ClassLayout.toPrintable:()Ljava/lang/String;       62: invokevirtual #19                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V       65: iinc          2, 1       68: goto          39       71: aload_1       72: monitorexit     //锁释放        73: goto          81       76: astore_3       77: aload_1       78: monitorexit    //锁释放        79: aload_3       80: athrow       81: return     Exception table:        from    to  target type            7    73    76   any           76    79    76   anyåå\n\n\n\n123456789101112public synchronized void testSpin1();   descriptor: ()V   flags: ACC_PUBLIC, ACC_SYNCHRONIZED // 锁标志   Code:     stack=3, locals=3, args_size=1        0: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;        3: new           #12                 // class java/lang/StringBuilder        6: dup        7: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V       10: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;       13: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;       16: invokevirtual #16      \n\n上面反编译后的代码可以看出，同步代码块是 monitorenter 和 monitorexit 实现的，同步方法是通过 ACC_SYNCHRONIZED 标志实现的。\n首先我们来看一下 JVM 规范中对于monitorenter和monitorexit的描述：\nmonitorenterEach object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:\n\nIf the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.\nIf the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.\nIf another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.\n\n翻译过来：\n每一个对象都会和一个监视器 monitor 关联。监视器被占用时会被锁住，其他线程无法来获取该 monitor。当 JVM 执行某个线程的某个方法内部的 monitorenter 时，它会尝试去获取当前对象对应的 monitor 的所有权。其过程如下：\n\n若 monior 的进入数为 0，线程可以进入 monitor，并将 monitor 的进入数置为 1。当前线程成为 monitor 的 owner（所有者）\n\n若线程已拥有 monitor 的所有权，允许它重入 monitor，则进入 monitor 的进入数加 1\n\n若其他线程已经占有 monitor 的所有权，那么当前尝试获取 monitor 的所有权的线程会被阻塞，直到 monitor 的进入数变为 0，才能重新尝试获取 monitor 的所有权。\n\n\nsynchronized 的锁对象会关联一个 monitor,这个 monitor 不是我们主动创建的,是 JVM 的线程执行到这个同步代码块,发现锁对象没有 monitor 就会创建 monitor,monitor 内部有两个重要的成员变量 owner:拥有这把锁的线程,recursions 会记录线程拥有锁的次数,当一个线程拥有 monitor 后其他线程只能等待。\nmonitorexitThe objectref must be of type reference.\nThe thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.\nThe thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.\n翻译过来：\n\n能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程。\n\n执行 monitorexit 时会将 monitor 的进入数减 1。当 monitor 的进入数减为 0 时，当前线程退出 monitor，不再拥有 monitor 的所有权，此时其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权。\n\n\nmonitorexit 插入在方法结束处和异常处，JVM 保证每个 monitorenter 必须有对应的 monitorexit。\n同步方法（ACC_SYNCHRONIZED）首先看看JVM文档对于 Synchronization 的介绍，可以总结为：同步方法在反汇编后，会增加 ACC_SYNCHRONIZED 修饰。会隐式调用 monitorenter 和 monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。\nmonitor 锁可以看出无论是 synchronized 代码块还是 synchronized 方法，其线程安全的语义实现最终依赖一个叫 monitor 的东西，那么这个神秘的东西,是什么呢？\n下面让我们来详细介绍一下。在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 c++来实现的，位于 HotSpot 虚拟机源码ObjectMonitor.hpp文件中。ObjectMonitor 主要数据结构如下：\n12345678910111213141516171819ObjectMonitor() &#123;    _header       = NULL;    _count        = 0;    _waiters      = 0,    _recursions   = 0;\t\t// 线程的重入次数    _object       = NULL;\t\t// 存储该monitor的对象    _owner        = NULL;\t\t// 标识拥有该monitor的线程    _WaitSet      = NULL;\t\t// 处于wait状态的线程，会被加入到_WaitSet    _WaitSetLock  = 0 ;    _Responsible  = NULL ;    _succ         = NULL ;    _cxq          = NULL ;\t\t// 多线程竞争锁时的单向列表    FreeNext      = NULL ;    _EntryList    = NULL ;\t\t// 处于等待锁block状态的线程，会被加入到该列表    _SpinFreq     = 0 ;    _SpinClock    = 0 ;    OwnerIsThread = 0 ;    _previous_owner_tid = 0;  &#125;\n\n\n\n\nowner：初始时为 NULL。当有线程占有该 monitor 时，owner 标记为该线程的唯一标识。当线程释放 monitor 时，owner 又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线程安全的。\ncxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。cxq 是一个临界资源，JVM 通过 CAS 原子指令来修改 cxq 队列。修改前 cxq 的旧值填入了 node 的 next 字段，cxq 指向新值（新线程）。因此 cxq 是一个后进先出的 stack（栈）。\nEntryList：cxq 队列中有资格成为候选资源的线程会被移动到该队列中。\nWaitSet：因为调用 wait 方法而被阻塞的线程会被放在该队列中。\n\n每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor。\n我们的 Java 代码里不会显示地去创造这么一个 monitor 对象，我们也无需创建，事实上可以这么理解：monitor 并不是随着对象创建而创建的。我们是通过 synchronized 修饰符告诉 JVM 需要为我们的某个对象创建关联的 monitor 对象。每个线程都存在两个 ObjectMonitor 对象列表，分别为 free 和 used 列表。同时 JVM 中也维护着 global locklist。当线程需要 ObjectMonitor 对象时，首先从线程自身的 free 表中申请，若存在则使用，若不存在则从 global list 中申请。\nObjectMonitor 的数据结构中包含：owner、WaitSet 和_EntryList，它们之间的关系转换可以用下图表示：\n\n\nsynchronized锁升级\n\n高效并发是从 JDK 5 到 JDK 6 的一个重要改进，HotSpot 虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。\n\n偏向锁偏向锁是 JDK 6 中的重要引进，因为 HotSpot 作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程 ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID 即可。\n偏向锁与 hashcode偏向锁的时候，对象头中保存的是线程 ID，那么 hashcode 保存在哪里呢，或者是先计算了 hashcode，还能实现偏向锁吗？\n\n当一个对象已经计算过 identity hash code，它就无法进入偏向锁状态；\n当一个对象当前正处于偏向锁状态，并且需要计算其 identity hash code 的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；\n重量锁的实现中，ObjectMonitor 类里有字段可以记录非加锁状态下的 mark word，其中可以存储 identity hash code 的值。或者简单说就是重量锁可以存下 identity hash code。\n\n\n请一定要注意，这里讨论的 hash code 都只针对 identity hash code。用户自定义的 hashCode()方法所返回的值跟这里讨论的不是一回事。Identity hash code 是未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。\n\n偏向锁获取当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：\n\n虚拟机将会把对象头中的偏向模式为“1”，即偏向模式；\n同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。\n\n具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 Java 虚拟机会通过 CAS 操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为：1 01；\n在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为： 1 01，是否包含当前线程的地址，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回；\n偏向锁撤销\n偏向锁的撤销动作必须等待safepoint（安全点）其他资料；\n暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态；\n撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态。\n\nepoch 是什么如果某一类锁对象的总撤销数超过了一个阈值（对应 jvm 参数 -XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 Java 虚拟机会宣布这个类的偏向锁失效；进行批量重偏向；具体的做法便是在每个类中维护一个 epoch 值，你可以理解为第几代偏向锁。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中；\n在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值；为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态；\n如果总撤销数超过另一个阈值（对应 jvm 参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁(这里说的就是偏向批量撤销)。\n偏向锁的相关参数偏向锁在 Java 6 之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用-XX:BiasedLockingStartupDelay=0 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 XX:-UseBiasedLocking=false 参数关闭偏向锁。\n偏向锁的使用场景\n偏向锁是为了在资源没有被多线程竞争的情况下尽量减少锁带来的性能开销。\n在锁对象的对象头中有一个ThreadId字段，当第一个线程访问锁时，如果该锁没有被其他线程访问过，即 ThreadId字段为空，那么 JVM 让其持有偏向锁，并将ThreadId字段的值设置为该线程的ID。当下一次获取锁的时候，会判断ThreadId是否相等，如果一致就不会重复获取锁，从而提高了运行效率。\n如果存在锁的竞争情况，偏向锁就会被撤销并升级为轻量级锁。\n\n偏向锁的状态匿名偏向(Anonymously biased)在此状态下thread pointer为NULL(0)，意味着还没有线程偏向于这个锁对象。第一个试图获取该锁的线程将会面临这个情况，使用原子CAS指令可将该锁对象绑定于当前线程。这是允许偏向锁的类对象的初始状态。\n可重偏向(Rebiasable)在此状态下，偏向锁的epoch字段是无效的（与锁对象对应的 class 的 mark_prototype 的 epoch 值不匹配）。下一个试图获取锁对象的线程将会面临这个情况，使用原子 CAS 指令可将该锁对象绑定于当前线程**。在批量重偏向的操作中，未被持有的锁对象都被至于这个状态，以便允许被快速重偏向。\n已偏向(Biased)这种状态下，thread pointer非空，且epoch为有效值——意味着其他线程正在持有这个锁对象。\n轻量级锁什么是轻量级锁轻量级锁是 JDK 6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。\n轻量级锁的获取当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：\n\n判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则 JVM 首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。\n\n\n\nJVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果成功表示竞争到锁，则将锁标志位变成 00，执行同步操作。\n\n\n\n如果失败则，这种情况：\n 判断当前对象的 Mark Word 是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，再增加一个 lock record，如图所示，然后执行同步代码块。\n否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成 10，后面等待的线程将会进入阻塞状态。\n\n\n\n\n轻量级锁的释放轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：\n\n取出在获取轻量级锁保存在 Displaced Mark Word 中的数据。\n\n用 CAS 操作将取出的数据替换当前对象的 Mark Word 中，如果成功，则说明释放锁成功。\n\n如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。\n\n\n轻量级锁的使用场景对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。\n重量级锁自旋锁前面我们讨论 monitor 实现锁的时候，知道 monitor 会阻塞和唤醒线程，线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自旋) , 这项技术就是所谓的自旋锁。自旋锁在 JDK 1.4.2 中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning 参数来开启，在 JDK 6 中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。\n自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户可以使用参数-XX : PreBlockSpin 来更改。\n适应性自旋锁在 JDK 6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如 100 次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。\n锁消除锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。\n锁消除的主要判定依据来源于逃逸分析（参考附录）的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。\n变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在 Java 程序中的普遍程度也许超过了大部分读者的想象。\n下面这段非常简单的代码仅仅是输出 3 个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步,虚拟机发现它的动态作用域被限制在 concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃逸”到 concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。\n123456789public class LockCoarsening &#123;    public static void main(String[] args) &#123;        concatString(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;);    &#125;    public static String concatString(String str1, String str2, String str3, String str4) &#123;        return new StringBuffer().append(str1).append(str2).append(str3).append(str4).toString();    &#125;&#125;\n\n复制代码\n锁粗化原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。\n","dateCreated":"2022-11-09T22:05:22+08:00","dateModified":"2022-11-12T10:19:11+08:00","datePublished":"2022-11-09T22:05:22+08:00","description":"众所周知 synchronized 锁在 Java 中经常使用它的源码是 C++ 实现的，它的实现原理是怎样的呢？本文以 OpenJDK 8 为例探究以下内容。","headline":"Synchronized原理","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.zcgr.xyz/synchronized-principle/"},"publisher":{"@type":"Organization","name":"kevin","sameAs":["mailto"],"image":"author.jpg","logo":{"@type":"ImageObject","url":"author.jpg"}},"url":"https://www.zcgr.xyz/synchronized-principle/","keywords":"synchronized"}</script>
    <meta name="description" content="众所周知 synchronized 锁在 Java 中经常使用它的源码是 C++ 实现的，它的实现原理是怎样的呢？本文以 OpenJDK 8 为例探究以下内容。">
<meta property="og:type" content="blog">
<meta property="og:title" content="Synchronized原理">
<meta property="og:url" content="https://www.zcgr.xyz/synchronized-principle/index.html">
<meta property="og:site_name" content="ZCGR">
<meta property="og:description" content="众所周知 synchronized 锁在 Java 中经常使用它的源码是 C++ 实现的，它的实现原理是怎样的呢？本文以 OpenJDK 8 为例探究以下内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211092237266.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102223816.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211092247770.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102227819.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102247807.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102248382.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102248676.png">
<meta property="article:published_time" content="2022-11-09T14:05:22.000Z">
<meta property="article:modified_time" content="2022-11-12T02:19:11.083Z">
<meta property="article:author" content="kevin">
<meta property="article:tag" content="synchronized">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211092237266.png">
    
    
        
    
    
        <meta property="og:image" content="https://www.zcgr.xyz/assets/images/author.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-wczbhbyl6devet40dgajv25nrkwllcg2xctirc6nrhdhegiknonigzivuevl.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            ZCGR
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/author.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/author.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">kevin</h4>
                
                    <h5 class="sidebar-profile-bio"><p>不懂心理学的摄影师不是一个好的软件工程师。<br>本不想如此多才多艺，奈何生活所迫。<br>软件工程师是全职工作，<br>摄影和心理咨询是工作之余的个人爱好</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories/technology"
                            
                            rel="noopener"
                            title="技术"
                        >
                        <i class="sidebar-button-icon fa fa-solid fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">技术</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories/photography"
                            
                            rel="noopener"
                            title="摄影"
                        >
                        <i class="sidebar-button-icon fa fa-solid fa-camera" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">摄影</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories/psychology"
                            
                            rel="noopener"
                            title="心理学"
                        >
                        <i class="sidebar-button-icon fa fa-solid fa-users" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">心理学</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-regular fa-address-card" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Synchronized原理
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-11-09T22:05:22+08:00">
	
		    11月 09, 2022
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/technology/">technology</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>众所周知 <code>synchronized</code> 锁在 <code>Java</code> 中经常使用它的源码是 <code>C++</code> 实现的，它的实现原理是怎样的呢？本文以 <code>OpenJDK 8</code> 为例探究以下内容。</p>
<span id="more"></span>

<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E6%9F%A5%E7%9C%8B"><span class="toc-text">对象布局查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%84%E6%88%90"><span class="toc-text">对象组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE"><span class="toc-text">对象数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%8D%95%E5%85%83"><span class="toc-text">对齐单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9"><span class="toc-text">指针压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%8E%9F%E7%90%86"><span class="toc-text">synchronized原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#monitorenter"><span class="toc-text">monitorenter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitorexit"><span class="toc-text">monitorexit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%88ACC-SYNCHRONIZED%EF%BC%89"><span class="toc-text">同步方法（ACC_SYNCHRONIZED）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor-%E9%94%81"><span class="toc-text">monitor 锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-text">synchronized锁升级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E4%B8%8E-hashcode"><span class="toc-text">偏向锁与 hashcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E8%8E%B7%E5%8F%96"><span class="toc-text">偏向锁获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80"><span class="toc-text">偏向锁撤销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoch-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">epoch 是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-text">偏向锁的相关参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">偏向锁的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">偏向锁的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">什么是轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">轻量级锁的获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-text">轻量级锁的释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">轻量级锁的使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">重量级锁自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">适应性自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-text">锁粗化</span></a></li></ol></li></ol>



<hr>
<ul>
<li><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><h3 id="对象布局查看"><a href="#对象布局查看" class="headerlink" title="对象布局查看"></a>对象布局查看</h3><p>查看源代码之前，须熟悉java对象的布局，可以使用ClassLayout查看布局。</p>
<p>具体可以在 POM 文件中引入该依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">0.10</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用该语句可以获取对象的内存布局</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLayout.parseInstance(unsafeModel).toPrintable()</span><br></pre></td></tr></table></figure>

<h3 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h3><p>Java 内存对象由 3 部分组成</p>
<p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211092237266.png" alt="img"></p>
<ul>
<li><p>Mark Word：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在 32 位系统占 4 字节，在 64 位系统中占 8 字节；</p>
</li>
<li><p>Class Pointer：用来指向对象对应的 Class 对象（其对应的元数据对象）的内存地址。在 32 位系统占 4 字节，在 64 位系统中占 8 字节；</p>
</li>
<li><p>Length：如果是数组对象，还有一个保存数组长度的空间，占 4 个字节；</p>
</li>
</ul>
<h3 id="对象数据"><a href="#对象数据" class="headerlink" title="对象数据"></a>对象数据</h3><p>对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte 和 boolean 是 1 个字节，short 和 char 是 2 个字节，int 和 float 是 4 个字节，long 和 double 是 8 个字节，reference 是 4 个字节（64 位系统中是 8 个字节）。</p>
<h3 id="对齐单元"><a href="#对齐单元" class="headerlink" title="对齐单元"></a>对齐单元</h3><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。对象头正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102223816.jpg" alt="img"></p>
<h3 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h3></li>
</ul>
<p>这里说明一下 32 位系统和 64 位系统中对象所占用内存空间的大小：</p>
<ul>
<li>在 32 位系统下，存放 Class Pointer 的空间大小是 4 字节，MarkWord 是 4 字节，对象头为 8 字节;</li>
<li>在 64 位系统下，存放 Class Pointer 的空间大小是 8 字节，MarkWord 是 8 字节，对象头为 16 字节;</li>
<li>64 位开启指针压缩的情况下，存放 Class Pointer 的空间大小是 4 字节，<code>MarkWord</code>是 8 字节，对象头为 12 字节;</li>
<li>如果是数组对象，对象头的大小为：数组对象头 8 字节+数组长度 4 字节+对齐 4 字节=16 字节。其中对象引用占 4 字节（未开启指针压缩的 64 位为 8 字节），数组<code>MarkWord</code>为 4 字节（64 位未开启指针压缩的为 8 字节）;</li>
<li>静态属性不算在对象大小内。</li>
</ul>
<p>​        可以看到，64 位 JVM 消耗的内存会比 32 位的要多大约 1.5 倍，这是因为对象指针在 64 位 JVM 下有更宽的寻址。对于那些将要从 32 位平台移植到 64 位的应用来说，平白无辜多了 1/2 的内存占用，这是开发者不愿意看到的。</p>
<p>​        从 JDK 1.6 update14 开始，64 位的 JVM 正式支持了 -XX:+UseCompressedOops 这个可以压缩指针，起到节约内存占用的新参数。</p>
<p>​        在 Java 程序启动时增加 JVM 参数：<code>-XX:+UseCompressedOops</code>来启用。JDK 1.8，默认该参数就是开启的。</p>
<ul>
<li><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h2></li>
</ul>
<p>首先先简单的写 2 个有 synchronized 的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSpin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印对象头&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">4</span>) &#123;</span><br><span class="line">                    System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testSpin1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印对象头&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过 javap -v -p 反编译后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void testSpin();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=3, locals=4, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: getfield      #3                  // Field lock:Ljava/lang/Object;</span><br><span class="line">        4: dup</span><br><span class="line">        5: astore_1</span><br><span class="line">        6: monitorenter      //锁进入                 </span><br><span class="line">        7: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       10: new           #12                 // class java/lang/StringBuilder</span><br><span class="line">       13: dup</span><br><span class="line">       14: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       17: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       20: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       23: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       26: ldc           #17                 // String 打印对象头</span><br><span class="line">       28: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       31: invokevirtual #18                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">       34: invokevirtual #19                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       37: iconst_0</span><br><span class="line">       38: istore_2</span><br><span class="line">       39: iload_2</span><br><span class="line">       40: iconst_5</span><br><span class="line">       41: if_icmpge     71</span><br><span class="line">       44: iload_2</span><br><span class="line">       45: iconst_4</span><br><span class="line">       46: if_icmpne     65</span><br><span class="line">       49: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       52: aload_0</span><br><span class="line">       53: getfield      #3                  // Field lock:Ljava/lang/Object;</span><br><span class="line">       56: invokestatic  #20                 // Method org/openjdk/jol/info/ClassLayout.parseInstance:(Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">       59: invokevirtual #21                 // Method org/openjdk/jol/info/ClassLayout.toPrintable:()Ljava/lang/String;</span><br><span class="line">       62: invokevirtual #19                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       65: iinc          2, 1</span><br><span class="line">       68: goto          39</span><br><span class="line">       71: aload_1</span><br><span class="line">       72: monitorexit     //锁释放 </span><br><span class="line">       73: goto          81</span><br><span class="line">       76: astore_3</span><br><span class="line">       77: aload_1</span><br><span class="line">       78: monitorexit    //锁释放 </span><br><span class="line">       79: aload_3</span><br><span class="line">       80: athrow</span><br><span class="line">       81: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            7    73    76   any</span><br><span class="line">           76    79    76   anyåå</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void testSpin1();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_SYNCHRONIZED // 锁标志</span><br><span class="line">   Code:</span><br><span class="line">     stack=3, locals=3, args_size=1</span><br><span class="line">        0: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        3: new           #12                 // class java/lang/StringBuilder</span><br><span class="line">        6: dup</span><br><span class="line">        7: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       10: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       13: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       16: invokevirtual #16      </span><br></pre></td></tr></table></figure>

<p>上面反编译后的代码可以看出，同步代码块是 monitorenter 和 monitorexit 实现的，同步方法是通过 ACC_SYNCHRONIZED 标志实现的。</p>
<p>首先我们来看一下 JVM 规范中对于<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">monitorenter</a>和<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">monitorexit</a>的描述：</p>
<h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes <em>monitorenter</em> attempts to gain ownership of the monitor associated with <em>objectref</em>, as follows:</p>
<ul>
<li>If the entry count of the monitor associated with <em>objectref</em> is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</li>
<li>If the thread already owns the monitor associated with <em>objectref</em>, it reenters the monitor, incrementing its entry count.</li>
<li>If another thread already owns the monitor associated with <em>objectref</em>, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</li>
</ul>
<p>翻译过来：</p>
<p>每一个对象都会和一个监视器 monitor 关联。监视器被占用时会被锁住，其他线程无法来获取该 monitor。当 JVM 执行某个线程的某个方法内部的 monitorenter 时，它会尝试去获取当前对象对应的 monitor 的所有权。其过程如下：</p>
<ol>
<li><p>若 monior 的进入数为 0，线程可以进入 monitor，并将 monitor 的进入数置为 1。当前线程成为 monitor 的 owner（所有者）</p>
</li>
<li><p>若线程已拥有 monitor 的所有权，允许它重入 monitor，则进入 monitor 的进入数加 1</p>
</li>
<li><p>若其他线程已经占有 monitor 的所有权，那么当前尝试获取 monitor 的所有权的线程会被阻塞，直到 monitor 的进入数变为 0，才能重新尝试获取 monitor 的所有权。</p>
</li>
</ol>
<p>synchronized 的锁对象会关联一个 monitor,这个 monitor 不是我们主动创建的,是 JVM 的线程执行到这个同步代码块,发现锁对象没有 monitor 就会创建 monitor,monitor 内部有两个重要的成员变量 owner:拥有这把锁的线程,recursions 会记录线程拥有锁的次数,当一个线程拥有 monitor 后其他线程只能等待。</p>
<h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><p>The <em>objectref</em> must be of type <code>reference</code>.</p>
<p>The thread that executes <em>monitorexit</em> must be the owner of the monitor associated with the instance referenced by <em>objectref</em>.</p>
<p>The thread decrements the entry count of the monitor associated with <em>objectref</em>. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
<p>翻译过来：</p>
<ol>
<li><p>能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程。</p>
</li>
<li><p>执行 monitorexit 时会将 monitor 的进入数减 1。当 monitor 的进入数减为 0 时，当前线程退出 monitor，不再拥有 monitor 的所有权，此时其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
</li>
</ol>
<p>monitorexit 插入在方法结束处和异常处，JVM 保证每个 monitorenter 必须有对应的 monitorexit。</p>
<h3 id="同步方法（ACC-SYNCHRONIZED）"><a href="#同步方法（ACC-SYNCHRONIZED）" class="headerlink" title="同步方法（ACC_SYNCHRONIZED）"></a>同步方法（ACC_SYNCHRONIZED）</h3><p>首先看看<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">JVM文档</a>对于 Synchronization 的介绍，可以总结为：同步方法在反汇编后，会增加 ACC_SYNCHRONIZED 修饰。会隐式调用 monitorenter 和 monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。</p>
<h3 id="monitor-锁"><a href="#monitor-锁" class="headerlink" title="monitor 锁"></a>monitor 锁</h3><p>可以看出无论是 synchronized 代码块还是 synchronized 方法，其线程安全的语义实现最终依赖一个叫 monitor 的东西，那么这个神秘的东西,是什么呢？</p>
<p>下面让我们来详细介绍一下。在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 c++来实现的，位于 HotSpot 虚拟机源码<a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/69087d08d473/src/share/vm/runtime/objectMonitor.hpp">ObjectMonitor.hpp</a>文件中。ObjectMonitor 主要数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;		<span class="comment">// 线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;		<span class="comment">// 存储该monitor的对象</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>;		<span class="comment">// 标识拥有该monitor的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;		<span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;		<span class="comment">// 多线程竞争锁时的单向列表</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;		<span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>owner：初始时为 NULL。当有线程占有该 monitor 时，owner 标记为该线程的唯一标识。当线程释放 monitor 时，owner 又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线程安全的。</li>
<li>cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。cxq 是一个临界资源，JVM 通过 CAS 原子指令来修改 cxq 队列。修改前 cxq 的旧值填入了 node 的 next 字段，cxq 指向新值（新线程）。因此 cxq 是一个后进先出的 stack（栈）。</li>
<li>EntryList：cxq 队列中有资格成为候选资源的线程会被移动到该队列中。</li>
<li>WaitSet：因为调用 wait 方法而被阻塞的线程会被放在该队列中。</li>
</ol>
<p>每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor。</p>
<p>我们的 Java 代码里不会显示地去创造这么一个 monitor 对象，我们也无需创建，事实上可以这么理解：monitor 并不是随着对象创建而创建的。我们是通过 synchronized 修饰符告诉 JVM 需要为我们的某个对象创建关联的 monitor 对象。每个线程都存在两个 ObjectMonitor 对象列表，分别为 free 和 used 列表。同时 JVM 中也维护着 global locklist。当线程需要 ObjectMonitor 对象时，首先从线程自身的 free 表中申请，若存在则使用，若不存在则从 global list 中申请。</p>
<p>ObjectMonitor 的数据结构中包含：owner、WaitSet 和_EntryList，它们之间的关系转换可以用下图表示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211092247770.jpeg" alt="img"></p>
<ul>
<li><h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2></li>
</ul>
<p>高效并发是从 JDK 5 到 JDK 6 的一个重要改进，HotSpot 虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102227819.png" alt="img"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是 JDK 6 中的重要引进，因为 HotSpot 作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程 ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID 即可。</p>
<h4 id="偏向锁与-hashcode"><a href="#偏向锁与-hashcode" class="headerlink" title="偏向锁与 hashcode"></a>偏向锁与 hashcode</h4><p>偏向锁的时候，对象头中保存的是线程 ID，那么 hashcode 保存在哪里呢，或者是先计算了 hashcode，还能实现偏向锁吗？</p>
<ul>
<li>当一个对象已经计算过 identity hash code，它就无法进入偏向锁状态；</li>
<li>当一个对象当前正处于偏向锁状态，并且需要计算其 identity hash code 的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li>
<li>重量锁的实现中，ObjectMonitor 类里有字段可以记录非加锁状态下的 mark word，其中可以存储 identity hash code 的值。或者简单说就是重量锁可以存下 identity hash code。</li>
</ul>
<blockquote>
<p>请一定要注意，这里讨论的 hash code 都只针对 identity hash code。用户自定义的 hashCode()方法所返回的值跟这里讨论的不是一回事。Identity hash code 是未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。</p>
</blockquote>
<h4 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h4><p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p>
<ol>
<li>虚拟机将会把对象头中的偏向模式为“1”，即偏向模式；</li>
<li>同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li>
</ol>
<p>具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 Java 虚拟机会通过 CAS 操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为：1 01；</p>
<p>在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为： 1 01，是否包含当前线程的地址，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回；</p>
<h4 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h4><ol>
<li>偏向锁的撤销动作必须等待<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29268019">safepoint</a>（<a target="_blank" rel="noopener" href="https://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html">安全点</a>）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c79c5e02ebe6">其他资料</a>；</li>
<li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态。</li>
</ol>
<h4 id="epoch-是什么"><a href="#epoch-是什么" class="headerlink" title="epoch 是什么"></a>epoch 是什么</h4><p>如果某一类锁对象的总撤销数超过了一个阈值（对应 jvm 参数 <strong>-XX:BiasedLockingBulkRebiasThreshold，默认为 20</strong>），那么 Java 虚拟机会宣布这个类的偏向锁失效；进行<strong>批量重偏向；</strong>具体的做法便是在每个类中维护一个 epoch 值，你可以理解为第几代偏向锁。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中；</p>
<p>在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值；为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态；</p>
<p>如果总撤销数超过另一个阈值（对应 jvm 参数 <strong>-XX:BiasedLockingBulkRevokeThreshold，默认值为 40</strong>），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁(这里说的就是<strong>偏向批量撤销</strong>)。</p>
<h4 id="偏向锁的相关参数"><a href="#偏向锁的相关参数" class="headerlink" title="偏向锁的相关参数"></a>偏向锁的相关参数</h4><p>偏向锁在 Java 6 之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用<code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p>
<h4 id="偏向锁的使用场景"><a href="#偏向锁的使用场景" class="headerlink" title="偏向锁的使用场景"></a>偏向锁的使用场景</h4><ol>
<li><strong>偏向锁是为了在资源没有被多线程竞争的情况下尽量减少锁带来的性能开销。</strong></li>
<li>在锁对象的对象头中有一个<code>ThreadId</code>字段，当<strong>第一个线程访问锁</strong>时，如果<strong>该锁没有被其他线程访问过</strong>，即 <strong><code>ThreadId</code>字段为空</strong>，那么 JVM 让其持有偏向锁，并将<code>ThreadId</code>字段的值设置为该线程的<code>ID</code>。当下一次获取锁的时候，会判断<code>ThreadId</code>是否相等，如果一致就不会重复获取锁，从而提高了运行效率。</li>
<li>如果存在锁的竞争情况，偏向锁就会被撤销并升级为轻量级锁。</li>
</ol>
<h4 id="偏向锁的状态"><a href="#偏向锁的状态" class="headerlink" title="偏向锁的状态"></a>偏向锁的状态</h4><p>匿名偏向(Anonymously biased)在此状态下<code>thread pointer</code>为<code>NULL(0)</code>，意味着还没有线程偏向于这个锁对象。第一个试图获取该锁的线程将会面临这个情况，使用原子<code>CAS</code>指令可将该锁对象绑定于当前线程。这是允许偏向锁的类对象的初始状态。</p>
<p>可重偏向(Rebiasable)在此状态下，偏向锁的<code>epoch</code>字段是无效的（与锁对象对应的 class 的 mark_prototype 的 epoch 值不匹配）。下一个试图获取锁对象的线程将会面临这个情况，使用原子 CAS 指令可将该锁对象绑定于当前线程**。在批量重偏向的操作中，未被持有的锁对象都被至于这个状态，以便允许被快速重偏向。</p>
<p>已偏向(Biased)这种状态下，<code>thread pointer</code>非空，且<code>epoch</code>为有效值——意味着其他线程正在持有这个锁对象。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h4><p>轻量级锁是 JDK 6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p>
<h4 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h4><p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则 JVM 首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102247807.jpeg" alt="img"></p>
<ol start="2">
<li>JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果成功表示竞争到锁，则将锁标志位变成 00，执行同步操作。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102248382.jpeg" alt="img"></p>
<ol start="3">
<li>如果失败则，这种情况：<ol>
<li> 判断当前对象的 Mark Word 是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，再增加一个 lock record，如图所示，然后执行同步代码块。</li>
<li>否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成 10，后面等待的线程将会进入阻塞状态。</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202211102248676.png" alt="img"></p>
<h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：</p>
<ol>
<li><p>取出在获取轻量级锁保存在 Displaced Mark Word 中的数据。</p>
</li>
<li><p>用 CAS 操作将取出的数据替换当前对象的 Mark Word 中，如果成功，则说明释放锁成功。</p>
</li>
<li><p>如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。</p>
</li>
</ol>
<h4 id="轻量级锁的使用场景"><a href="#轻量级锁的使用场景" class="headerlink" title="轻量级锁的使用场景"></a>轻量级锁的使用场景</h4><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<h3 id="重量级锁自旋锁"><a href="#重量级锁自旋锁" class="headerlink" title="重量级锁自旋锁"></a>重量级锁自旋锁</h3><p>前面我们讨论 monitor 实现锁的时候，知道 monitor 会阻塞和唤醒线程，线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自旋) , 这项技术就是所谓的自旋锁。自旋锁在 JDK 1.4.2 中就已经引入，只不过默认是关闭的，可以使用<code>-XX:+UseSpinning</code> 参数来开启，在 JDK 6 中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<p>自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户可以使用参数<code>-XX : PreBlockSpin</code> 来更改。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>在 JDK 6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如 100 次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器（<a href="https://xie.infoq.cn/link?target=http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">JIT</a>）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p>
<p>锁消除的主要判定依据来源于<strong>逃逸分析（参考附录</strong>）的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p>
<p>变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在 Java 程序中的普遍程度也许超过了大部分读者的想象。</p>
<p>下面这段非常简单的代码仅仅是输出 3 个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步,虚拟机发现它的动态作用域被限制在 concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃逸”到 concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockCoarsening</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        concatString(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String str1, String str2, String str3, String str4)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(str1).append(str2).append(str3).append(str4).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/all-tags/synchronized/" rel="tag">synchronized</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/beijing-happy-valley-ph/"
                    data-tooltip="新的一年，从不给自己设限开始"
                    aria-label="上一篇: 新的一年，从不给自己设限开始"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/psychology-test1/"
                    data-tooltip="Psychology-Test1"
                    aria-label="下一篇: Psychology-Test1"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 kevin. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/beijing-happy-valley-ph/"
                    data-tooltip="新的一年，从不给自己设限开始"
                    aria-label="上一篇: 新的一年，从不给自己设限开始"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/psychology-test1/"
                    data-tooltip="Psychology-Test1"
                    aria-label="下一篇: Psychology-Test1"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/author.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">kevin</h4>
        
            <div id="about-card-bio"><p>不懂心理学的摄影师不是一个好的软件工程师。<br>本不想如此多才多艺，奈何生活所迫。<br>软件工程师是全职工作，<br>摄影和心理咨询是工作之余的个人爱好</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>软件工程师<br>摄影师<br>心理咨询师</p>

            </div>
        
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="/assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/technology-test/"
                            aria-label=": Technology-Test"
                        >
                            <h3 class="media-heading">Technology-Test</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2022年11月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>technology test</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/photography-test/"
                            aria-label=": Photography-Test"
                        >
                            <h3 class="media-heading">Photography-Test</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2022年11月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>photography test</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/psychology-test/"
                            aria-label=": Psychology-Test"
                        >
                            <h3 class="media-heading">Psychology-Test</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2022年11月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>psychology test</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/technology-test1/"
                            aria-label=": Technology-Test1"
                        >
                            <h3 class="media-heading">Technology-Test1</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2022年11月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>technology-test1</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/photography-test1/"
                            aria-label=": Photography-Test1"
                        >
                            <h3 class="media-heading">Photography-Test1</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2022年11月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>photography-test1</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/psychology-test1/"
                            aria-label=": Psychology-Test1"
                        >
                            <h3 class="media-heading">Psychology-Test1</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2022年11月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>psychology-test1</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/synchronized-principle/"
                            aria-label=": Synchronized原理"
                        >
                            <h3 class="media-heading">Synchronized原理</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2022年11月9日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>众所周知 <code>synchronized</code> 锁在 <code>Java</code> 中经常使用它的源码是 <code>C++</code> 实现的，它的实现原理是怎样的呢？本文以 <code>OpenJDK 8</code> 为例探究以下内容。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/beijing-happy-valley-ph/"
                            aria-label=": 新的一年，从不给自己设限开始"
                        >
                            <h3 class="media-heading">新的一年，从不给自己设限开始</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2023年1月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><img src="https://cdn.jsdelivr.net/gh/jacks-kevin-lee/web-resource/img/202301201605209.jpeg" alt="北京欢乐谷"></p>
<p>​    每年都想写些什么，但总找不到合适的动力。经历了2022年这一无常的一年，终于攒够了记录生活的动力。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://www.zcgr.xyz/traces-of-poverty/"
                            aria-label=": 贫穷的痕迹，上大学就能抹去吗？"
                        >
                            <h3 class="media-heading">贫穷的痕迹，上大学就能抹去吗？</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2023年1月10日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>作者：艾苓，黑龙江绥化学院教授。从教 17 年，接触学生超过 3000 人。2017 年通过社交平台发布《贫困生调查说明》，收到学生广泛响应。她详细追踪了 56 个孩子的人生轨迹，以当事人口述形式，记录下他们为了改变命运，做出的惊心动魄的努力。部分内容曾在《读库》发表，引发广泛讨论。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 9 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-hncq7mi6zjcbcwnu7mypynufcy9otbe8y6y4wq5t1nubs504qy7u3dowlrq0.min.js"></script>

<!--SCRIPTS END-->


    



    
<script src="/assets/js/moment-with-locales.js"></script>

    
<script src="/assets/js/algoliasearch.js"></script>

    <script>
      var algoliaClient = algoliasearch('9NRAR8EFQK', '27ad12d7095621830a22fc3883f0658c');
      var algoliaIndex = algoliaClient.initIndex('dev-hexo');
    </script>


    </body>
</html>
